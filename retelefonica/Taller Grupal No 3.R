
if (!require('readxl')) install.packages('readxl')
if (!require('caret')) install.packages('caret')
if (!require('ROCR')) install.packages('ROCR')
if (!require('lift')) install.packages('lift')
if (!require('tidyverse')) install.packages('tidyverse')
if (!require('MLmetrics')) install.packages('MLmetrics')
if (!requireNamespace("lubridate", quietly = TRUE)) {
  install.packages("lubridate")
}
library(lubridate)

getwd()

df_original <- read_excel("traintelco.xlsx")
df <- as.data.frame(df_original)
df %>% glimpse()
df <- df %>% rename(tipo_cliente = 'tipo cliente')
df <- df %>% rename(fecha_de_nacimiento = 'Fecha de nacimiento')
df <- df %>% rename(factura_online = 'Factura online')
df <- df %>% rename(antiguedad_equipo = 'Antigüedad Equipo')
df <- df %>% rename(plan_de_datos = 'Plan de datos')
df <- df %>% rename(fecha_inicio_contrato = 'Fecha inicio contrato')

df$tipo_cliente <- as.factor(df$tipo_cliente)
df$fecha_de_nacimiento <- as.Date(df$fecha_de_nacimiento, format = "%d-%m-%y")
df$fecha_inicio_contrato <- as.Date(df$fecha_inicio_contrato, format = "%d-%m-%y")

fecha_actual <- as.Date("2024-05-04")
str(df)


# Función para calcular la edad en años
calcular_edad <- function(fecha_de_nacimiento, fecha_actual) {
  diferencia <- difftime(fecha_actual, fecha_de_nacimiento, units = "days")/365.25
  return(diferencia)}
 
# Calcular la edad en años para cada fecha en el dataframe usando la fecha de nacimiento fija como referencia
df$edad <- round(as.numeric(calcular_edad(df$fecha_de_nacimiento, fecha_actual)),2)

# Función para calcular tiempo contrato
calcular_tiempo <- function(fecha_inicio_contrato, fecha_actual) {
  diferencia <- difftime(fecha_actual, fecha_inicio_contrato, units = "days")/30
  return(diferencia)}

# Calcular tiempo contrato en meses para cada fecha en el dataframe usando la fecha_inicio_contrato como referencia
df$tiempo_contrato <- round(as.numeric(calcular_tiempo(df$fecha_inicio_contrato, fecha_actual)),2)

# Creación de dummy para 'tipo cliente'
df_win <- dummyVars(formula = ~ tipo_cliente+ ., data = df)
df_fin <- as.data.frame(predict(df_win,newdata=df))
df_fin %>% glimpse()

#Eliminar una categor?a por variable dummy y variable id
#df_fin2 <- df_fin %>% select(-c(tipo_cliente.3,'id'))
df_fin2 <- df_fin %>% select(-c(tipo_cliente.3, antiguedad_equipo, plan_de_datos, minutos, 'id',fecha_de_nacimiento,fecha_inicio_contrato,factura_online))
df_fin2 %>% View()

df_fin2$facturación <- scale(df_fin2$facturación)

names(df_fin2)[names(df_fin2) == "facturación[,1]"] <- "facturación"

boxplot(df_fin2)

# Identificar valores atípicos
outliers <- df_fin2 > upper_threshold | df_fin2 < lower_threshold

# Exploración variable de respuesta
balance <- table(df$resultado)
prop.table(balance)

# Partición de la base
set.seed(30459) 
# Aquí se define el tamaño de la muestra, en este caso entrenamiento tendrá el 75% de los casos
sample <- sample.int(nrow(df_fin2), floor(.75*nrow(df_fin2)))
df.train <- df_fin2[sample, ]
df.test <- df_fin2[-sample, ]

datos.test <- subset(df.test, select = -resultado)


## Modelo
modelo.logit <- glm(resultado~., family=binomial, df_fin2)
# trace=0 impide ver todos los detalles de la optimización stepwise


steplogit <- step(modelo.logit, direction="both", trace=0)
summary(steplogit)



# Crea el pronóstico en base de prueba
probtest <- predict(steplogit, newdata = datos.test, type='response')
test_con_prob <- df.test %>% 
  mutate(probabilidades = probtest)

# Crear objeto de predicciones
pr <- prediction(probtest, df.test$resultado)
pr@predictions

# Calcular el AUC
auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
# Ver el AUC
auc


#_____________TEST_____________________

df_test <- read_excel("testelco.xlsx")
df_test <- as.data.frame(df_test)
df_test %>% glimpse()
df_test <- df_test %>% rename(tipo_cliente = 'tipo cliente')
df_test <- df_test %>% rename(fecha_de_nacimiento = 'Fecha de nacimiento')
df_test <- df_test %>% rename(factura_online = 'Factura online')
df_test <- df_test %>% rename(antiguedad_equipo = 'Antigüedad Equipo')
df_test <- df_test %>% rename(plan_de_datos = 'Plan de datos')
df_test <- df_test %>% rename(fecha_inicio_contrato = 'Fecha inicio contrato')


df_test$tipo_cliente <- as.factor(df_test$tipo_cliente)
df_test$fecha_de_nacimiento <- as.Date(df_test$fecha_de_nacimiento, format = "%d-%m-%y")
df_test$fecha_inicio_contrato <- as.Date(df_test$fecha_inicio_contrato, format = "%d-%m-%y")


# Función para calcular la edad en años
calcular_edad <- function(fecha_de_nacimiento, fecha_actual) {
  diferencia <- difftime(fecha_actual, fecha_de_nacimiento, units = "days")/365.25
  return(diferencia)}

# Calcular la edad en años para cada fecha en el dataframe usando la fecha de nacimiento fija como referencia
df_test$edad <- round(as.numeric(calcular_edad(df_test$fecha_de_nacimiento, fecha_actual)),2)

# Función para calcular tiempo contrato
calcular_tiempo <- function(fecha_inicio_contrato, fecha_actual) {
  diferencia <- difftime(fecha_actual, fecha_inicio_contrato, units = "days")/30
  return(diferencia)}

# Calcular tiempo contrato en meses para cada fecha en el dataframe usando la fecha_inicio_contrato como referencia
df_test$tiempo_contrato <- round(as.numeric(calcular_tiempo(df_test$fecha_inicio_contrato, fecha_actual)),2)

# Creación de dummy para 'tipo cliente'
df_test_win <- dummyVars(formula = ~ tipo_cliente+ ., data = df_test)
df_test_fin <- as.data.frame(predict(df_test_win,newdata=df_test))
df_test_fin %>% glimpse()


#Eliminar una categor?a por variable dummy y variable id
df_id<- df_test_fin %>% select(c('id'))
#df_test_fin2 <- df_test_fin %>% select(-c(tipo_cliente.3,'id'))
#df_test_fin2 <- df_test_fin %>% select(-c(tipo_cliente.3,'id',fecha_de_nacimiento,fecha_inicio_contrato))
df_test_fin2 <- df_test_fin %>% select(-c(tipo_cliente.3, antiguedad_equipo, plan_de_datos, minutos, 'id',fecha_de_nacimiento,fecha_inicio_contrato,factura_online))

df_test_fin2 %>% View()

predicciones <- predict(modelo_stepwise, newdata = df_test_fin2)

# Crea el pronóstico en base de prueba

probtest <- predict(steplogit, newdata = df_test_fin2, type='response')
probtest

str(probtest)


datos_resultado_grupal7 <- data.frame(id = df_id$id, resultado = probtest)

ruta_archivo <- "C:/Users/vanes/Documents/Javeriana/Metodos aplicaciones/Regresión lineal/datos_resultado_grupal7.csv"
write.csv(datos_resultado_grupal7, file = ruta_archivo, row.names = FALSE)























#####################################################
#####################################################
#####################################################
#####################################################
#####################################################

## Modelo
modelo.logit <- glm(resultado~., family=binomial, df.train)
# trace=0 impide ver todos los detalles de la optimización stepwise
steplogit <- step(modelo.logit, direction="both", trace=0)
summary(steplogit)

coeficientes <- steplogit$coefficients
odd_change <- exp(coeficientes)
odd_change

# Odd ratios
oddbase<-prop.table(balance)[2]/prop.table(balance)[1]
oddbase
#Probabilidad de cambiar al cambiar en una unidad en las x
oddfin <- oddbase*odd_change
prob1step <- oddfin/(1+oddfin)
prob1step

# Análisis de no linealidad de los incrementos
# Crear matriz vacía
oddprueba <- matrix(,6,29)
probprueba <- matrix(,6,29)

# Borrar el intercepto
odd_change2 <- odd_change[2:7]

# Guardar odd base y probabilidad base
oddprueba[,11] <- oddbase
probprueba[,11] <- oddprueba[,11]/(1+oddprueba[,11])
# OJO-->La tasa de cambio del odds no es constante en el tiempo
# Calcular odds y probabilidades 17 pasos adelante
for (i in 12:29){ 
  oddprueba[,i] <- oddprueba[,i-1]*odd_change2
  probprueba[,i] <- oddprueba[,i]/(1+oddprueba[,i])
}
# y 10 atrás
for (i in 10:1){ 
  oddprueba[,i] <- oddprueba[,i+1]/odd_change2
  probprueba[,i] <- oddprueba[,i]/(1+oddprueba[,i])
}

# Guardar en un dataframe
probver <- as.data.frame(t(probprueba))
# Crear id y graficar: cartera insumos A
probver$id <- seq(1:29)-11
names(probver) <- c("Tipo IPS 1", "Tipo IPS 4", "años igual dueño",
                    "años dirección actual", "%pasivo/ venta anual",
                    "cartera insumos A", "pasos")
plot(probver$pasos, probver$`cartera insumos A`)

# Veamos las predicciones en la base de entrenamiento
df.train_2 <- df.train %>% 
  mutate(probabilidades = steplogit$fitted.values)

# Crea el pronóstico base de entrenamiento
prontrain <- ifelse(steplogit$fitted.values > 0.5,1,0)

# Matriz de confusión y estadísticas, base de entrenamiento
conftrain <- confusionMatrix(as.factor(prontrain),
                             df.train$resultado, positive = "1")
conftrain$table
conftrain$byClass

# Crea el pronóstico en base de prueba
probtest <- predict(steplogit, newdata = cartera.test, type='response')
test_con_prob <- cartera.test %>% 
  mutate(probabilidades = probtest)

# write.csv(test_con_prob, "prueba_prob.csv")

prontest <- ifelse(probtest > 0.5,1,0)
conftest <- confusionMatrix(as.factor(prontest),cartera.test$retrasos, 
                            positive = "1")
conftest$table
conftest$byClass

# F-beta score
FBeta_Score(cartera.test$retrasos, prontest, positive = "1", beta = 1)
FBeta_Score(cartera.test$retrasos, prontest, positive = "1", beta = 0.5)
FBeta_Score(cartera.test$retrasos, prontest, positive = "1", beta = 2)

# Crear objeto de predicciones
pr <- prediction(probtest, cartera.test$retrasos)
pr@predictions
# Cutoffs vs precisión
cut_prec <- performance(pr, measure = "prec")
plot(cut_prec)
# Cutoffs vs recall
cut_rec <- performance(pr, measure = "tpr")
plot(cut_rec)

# Curva ROC
curvaROC <- performance(pr, measure="tpr", x.measure="fpr")
# Gráfico de la curva
plot(curvaROC)
abline(h = 0.8)
# Calcular el AUC
auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
# Ver el AUC
auc


# Extrayendo las coordenadas de la curva ROC
fprs <- unlist(curvaROC@x.values)
tprs <- unlist(curvaROC@y.values)
tablaCOR <- as.data.frame(cbind(fprs,tprs))
tablaCOR[65:95,]


library("lift")
# Gráfico de lift
plotLift(probtest, cartera.test$retrasos, cumulative = FALSE)
abline(h = 1) # El lift que se tendr?a sin modelo

# lift acumulado
plotLift(probtest,cartera.test$retrasos, cumulative = TRUE)

gain<-performance(pr, "tpr", "rpp")
plot(gain)
abline(h = 0.8)

# Guardar las exhaustividades y puntos de corte
tablafinan <- performance(pr, measure="rec")
cutoffs <- unlist(tablafinan@x.values)
recalls <- unlist(tablafinan@y.values)
# Guardar las precisiones
tablafina2 <- performance(pr, measure="prec")
precisions <- unlist(tablafina2@y.values)
# Crear la tabla conjunta
tablacruce <- as.data.frame(cbind(cutoffs,precisions,recalls))
# Ver precisiones versus exhaustividad
tablacruce %>% ggplot(aes(x = precisions, y = recalls)) +
  geom_point() +
  theme_minimal()

# Ver cutoffs vs precisiones y recalls
tablacruce %>% ggplot() +
  geom_point(aes(x = cutoffs, y = precisions)) +
  geom_point(aes(x = cutoffs, y = recalls), color="darkred") +
  theme_minimal()


# Calcular las ganancias
tablacruce <- tablacruce %>% 
  mutate(wins = prop.table(balance)[2]*recalls*(500-(100/precisions)))


# Pintar las ganancias versus los cutoffs
tablacruce %>% 
  ggplot(aes(x = cutoffs, y = wins)) + 
  geom_point() +
  theme_minimal()

# Ver las ganancias frente a la precisión
tablacruce %>% 
  ggplot(aes(x = precisions, y = wins)) + 
  geom_point() +
  theme_minimal()

# Cutoff donde la ganancia es máxima
tablacruce[which.max(tablacruce$wins),]

# Balanceo
## separamos ceros y unos
no_retraso <- carterafin2 %>% 
  filter(retrasos == 0)

si_retraso <- carterafin2 %>% 
  filter(retrasos == 1)

# En ambas bases el 20% es prueba
set.seed(24029114)
# 20% de ceros
muestra <- sample.int(nrow(si_retraso), round(.2*nrow(si_retraso)))
si_retraso_test <- si_retraso[muestra, ]
si_retraso_resto <- si_retraso[-muestra, ]
# 20% de unos
muestra2 <- sample.int(nrow(no_retraso), round(.2*nrow(no_retraso)))
no_retraso_test <- no_retraso[muestra2, ]
no_retraso_resto <- no_retraso[-muestra2, ]

# Unir las dos
cart.test <- rbind(si_retraso_test, no_retraso_test)
nrow(cart.test)
prop.table(table(cart.test$retrasos))

muestra3 <- sample.int(nrow(si_retraso_resto), round(.5*nrow(si_retraso_resto)))
si_retraso_train <- si_retraso_resto[muestra3, ]
si_retraso_valid <- si_retraso_resto[-muestra3, ]

# Pongo la misma cantidad de ceros y unos en entrenamiento: 
muestra4 <- sample.int(nrow(no_retraso_resto), nrow(si_retraso_train))
no_retraso_train <- no_retraso_resto[muestra4, ]
no_retraso_valid <- no_retraso_resto[-muestra4, ]
# Creo entrenamiento y validaci?n
cart.train <- rbind(si_retraso_train, no_retraso_train)
cart.valid <- rbind(si_retraso_valid, no_retraso_valid)
# Chequeo que todo va bien
table(cart.train$retrasos)
table(cart.valid$retrasos)
table(cart.test$retrasos)
prop.table(table(cart.train$retrasos))
prop.table(table(cart.valid$retrasos))
prop.table(table(cart.test$retrasos))
prop.table(table(carterafin2$retrasos)) #proporciones originales


cart.train %>% ggplot(aes(x = `IGUAL_DUENO`, 
                          y = cartera_actual_insumos_A,
                          color = retrasos))+
  geom_point()+
  theme_minimal()


modelo.balance <- glm(retrasos~., family=binomial, cart.train)
stepbalance <- step(modelo.balance, direction="both", trace=0)
summary(stepbalance)

coeficientes2 <- stepbalance$coefficients
odd_changeb <- exp(coeficientes2)
odd_changeb


# Crea el pronóstico en prueba
probtest2 <- predict(stepbalance, newdata = cart.test, type='response')
prontest2 <- ifelse(probtest2 > 0.5, 1, 0)
conftest2 <- confusionMatrix(as.factor(prontest2),
                             cart.test$retrasos, positive = "1")
conftest2$table
conftest2$byClass

# Crear objeto de predicciones
pr2 <- prediction(probtest2, cart.test$retrasos)
# Creación del objeto de la curva
curvaROC2 <- performance(pr2, measure="tpr", x.measure="fpr")
# Gráfico de la curva
plot(curvaROC2)
abline(h = 0.8)
# Calcular el AUC
auc2 <- performance(pr2,measure = "auc")
auc2f <- auc2@y.values[[1]]
# Ver el AUC
auc2f

# Validación cruzada (sin balanceo)
datos_train <- rbind(cart.train, cart.valid)

train_control <- trainControl(method = "cv", number = 10)

# train the model on training set
model <- train(retrasos ~ .,
               data = datos_train,
               trControl = train_control,
               method = "glm",
               family = binomial())

# print cv scores
summary(model)

pred_test_cv <- predict(model, newdata = cart.test, type='prob')
pron_test_cv <- ifelse(pred_test_cv$`1` > 0.5, 1, 0)
conf_test_cv <- confusionMatrix(as.factor(pron_test_cv),
                             cart.test$retrasos, positive = "1")
conf_test_cv$table
conf_test_cv$byClass

# Crear objeto de predicciones
pred_cv <- prediction(pred_test_cv$`1`, cart.test$retrasos)
# Creación del objeto de la curva
curvaROC_cv <- performance(pred_cv, measure="tpr", x.measure="fpr")
# Gráfico de la curva
plot(curvaROC_cv)
abline(h = 0.8)
# Calcular el AUC
auc_cv <- performance(pred_cv, measure = "auc")
auc_cv1 <- auc_cv@y.values[[1]]
# Ver el AUC
auc_cv1

